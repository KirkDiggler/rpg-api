package v1alpha1_test

import (
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"go.uber.org/mock/gomock"

	dnd5ev1alpha1 "github.com/KirkDiggler/rpg-api-protos/gen/go/dnd5e/api/v1alpha1"
	"github.com/KirkDiggler/rpg-api/internal/handlers/dnd5e/v1alpha1"
	"github.com/KirkDiggler/rpg-api/internal/orchestrators/character"
	charactermock "github.com/KirkDiggler/rpg-api/internal/orchestrators/character/mock"
	toolkitchar "github.com/KirkDiggler/rpg-toolkit/rulebooks/dnd5e/character"
	"github.com/KirkDiggler/rpg-toolkit/rulebooks/dnd5e/constants"
)

func TestCreateThenUpdateRace_PreservesID(t *testing.T) {
	// GIVEN
	ctx := context.Background()
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockCharService := charactermock.NewMockService(ctrl)

	handler, err := v1alpha1.NewHandler(&v1alpha1.HandlerConfig{
		CharacterService: mockCharService,
	})
	require.NoError(t, err)

	playerID := "player-789"
	draftID := "draft-generated-123"

	// Step 1: Mock creating a draft
	createdDraft := &toolkitchar.DraftData{
		ID:        draftID, // This should be generated by the repository
		PlayerID:  playerID,
		Name:      "New Character",
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	mockCharService.EXPECT().
		CreateDraft(ctx, &character.CreateDraftInput{
			PlayerID: playerID,
			InitialData: &toolkitchar.DraftData{
				Name: "New Character",
			},
		}).
		Return(&character.CreateDraftOutput{
			Draft: createdDraft,
		}, nil)

	// Create the draft
	createReq := &dnd5ev1alpha1.CreateDraftRequest{
		PlayerId: playerID,
		InitialData: &dnd5ev1alpha1.CharacterDraftData{
			Name: "New Character",
		},
	}

	createResp, err := handler.CreateDraft(ctx, createReq)
	require.NoError(t, err)
	require.NotNil(t, createResp.Draft)
	assert.NotEmpty(t, createResp.Draft.Id, "Created draft should have an ID")
	assert.Equal(t, draftID, createResp.Draft.Id)

	// Step 2: Mock updating the race
	updatedDraft := &toolkitchar.DraftData{
		ID:        draftID, // Same ID
		PlayerID:  playerID,
		Name:      "New Character",
		CreatedAt: createdDraft.CreatedAt,
		UpdatedAt: time.Now(),
		RaceChoice: toolkitchar.RaceChoice{
			RaceID:    constants.RaceDwarf,
			SubraceID: constants.SubraceHillDwarf,
		},
	}

	mockCharService.EXPECT().
		UpdateRace(ctx, &character.UpdateRaceInput{
			DraftID:   draftID,
			RaceID:    constants.RaceDwarf,
			SubraceID: constants.SubraceHillDwarf,
			Choices:   nil,
		}).
		Return(&character.UpdateRaceOutput{
			Draft:    updatedDraft,
			Warnings: []character.ValidationWarning{},
		}, nil)

	// Update the race
	updateReq := &dnd5ev1alpha1.UpdateRaceRequest{
		DraftId: draftID,
		Race:    dnd5ev1alpha1.Race_RACE_DWARF,
		Subrace: dnd5ev1alpha1.Subrace_SUBRACE_HILL_DWARF,
	}

	updateResp, err := handler.UpdateRace(ctx, updateReq)

	// THEN
	require.NoError(t, err)
	require.NotNil(t, updateResp)
	require.NotNil(t, updateResp.Draft)

	// The critical assertion - ID should be the same after update
	assert.Equal(t, draftID, updateResp.Draft.Id, "Draft ID should be preserved after race update")
	assert.Equal(t, playerID, updateResp.Draft.PlayerId)
	assert.Equal(t, "New Character", updateResp.Draft.Name)
	assert.Equal(t, dnd5ev1alpha1.Race_RACE_DWARF, updateResp.Draft.RaceId)
	assert.Equal(t, dnd5ev1alpha1.Subrace_SUBRACE_HILL_DWARF, updateResp.Draft.SubraceId)
}
